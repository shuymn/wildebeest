// Code generated by sqlc-gen-ts-d1. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
//   sqlc-gen-ts-d1 v0.0.0-a@9af07320cda61bba7e9ed9a216e0c87d9e5e49c1

import { D1Database, D1Result } from "@cloudflare/workers-types"

const selectNotificationsByActorIdQuery = `-- name: SelectNotificationsByActorId :many
SELECT
  objects.id,
  objects.type,
  objects.properties,
  objects.mastodon_id,
  objects.cdate,
  objects.original_actor_id,
  actor_notifications.type AS notification_type,
  actor_notifications.actor_id AS notification_actor_id,
  actor_notifications.from_actor_id AS notification_from_actor_id,
  actor_notifications.cdate AS notification_cdate,
  actor_notifications.id AS notification_id
FROM
  actor_notifications
  LEFT JOIN objects ON objects.id = actor_notifications.object_id
WHERE
  actor_notifications.actor_id = ?1
ORDER BY
  actor_notifications.cdate DESC
LIMIT
  ?2`;

export type SelectNotificationsByActorIdParams = {
  actorId: string;
  limit: number;
};

export type SelectNotificationsByActorIdRow = {
  id: string;
  type: string;
  properties: string;
  mastodonId: string;
  cdate: string;
  originalActorId: string | null;
  notificationType: string;
  notificationActorId: string;
  notificationFromActorId: string;
  notificationCdate: string;
  notificationId: number;
};

type RawSelectNotificationsByActorIdRow = {
  id: string;
  type: string;
  properties: string;
  mastodon_id: string;
  cdate: string;
  original_actor_id: string | null;
  notification_type: string;
  notification_actor_id: string;
  notification_from_actor_id: string;
  notification_cdate: string;
  notification_id: number;
};

export async function selectNotificationsByActorId(
  d1: D1Database,
  args: SelectNotificationsByActorIdParams
): Promise<D1Result<SelectNotificationsByActorIdRow>> {
  return await d1
    .prepare(selectNotificationsByActorIdQuery)
    .bind(args.actorId, args.limit)
    .all<RawSelectNotificationsByActorIdRow>()
    .then((r: D1Result<RawSelectNotificationsByActorIdRow>) => { return {
      ...r,
      results: r.results.map((raw: RawSelectNotificationsByActorIdRow) => { return {
        id: raw.id,
        type: raw.type,
        properties: raw.properties,
        mastodonId: raw.mastodon_id,
        cdate: raw.cdate,
        originalActorId: raw.original_actor_id,
        notificationType: raw.notification_type,
        notificationActorId: raw.notification_actor_id,
        notificationFromActorId: raw.notification_from_actor_id,
        notificationCdate: raw.notification_cdate,
        notificationId: raw.notification_id,
      }}),
    }});
}

const selectNotificationsByIdAndActorIdQuery = `-- name: SelectNotificationsByIdAndActorId :one
SELECT
  objects.id,
  objects.type,
  objects.properties,
  objects.mastodon_id,
  objects.cdate,
  objects.original_actor_id,
  actor_notifications.type AS notification_type,
  actor_notifications.actor_id AS notification_actor_id,
  actor_notifications.from_actor_id AS notification_from_actor_id,
  actor_notifications.cdate AS notification_cdate,
  actor_notifications.id AS notification_id
FROM
  actor_notifications
  LEFT JOIN objects ON objects.id = actor_notifications.object_id
WHERE
  actor_notifications.id = ?
  AND actor_notifications.actor_id = ?`;

export type SelectNotificationsByIdAndActorIdParams = {
  id: number;
  actorId: string;
};

export type SelectNotificationsByIdAndActorIdRow = {
  id: string;
  type: string;
  properties: string;
  mastodonId: string;
  cdate: string;
  originalActorId: string | null;
  notificationType: string;
  notificationActorId: string;
  notificationFromActorId: string;
  notificationCdate: string;
  notificationId: number;
};

type RawSelectNotificationsByIdAndActorIdRow = {
  id: string;
  type: string;
  properties: string;
  mastodon_id: string;
  cdate: string;
  original_actor_id: string | null;
  notification_type: string;
  notification_actor_id: string;
  notification_from_actor_id: string;
  notification_cdate: string;
  notification_id: number;
};

export async function selectNotificationsByIdAndActorId(
  d1: D1Database,
  args: SelectNotificationsByIdAndActorIdParams
): Promise<SelectNotificationsByIdAndActorIdRow | null> {
  return await d1
    .prepare(selectNotificationsByIdAndActorIdQuery)
    .bind(args.id, args.actorId)
    .first<RawSelectNotificationsByIdAndActorIdRow | null>()
    .then((raw: RawSelectNotificationsByIdAndActorIdRow | null) => raw ? {
      id: raw.id,
      type: raw.type,
      properties: raw.properties,
      mastodonId: raw.mastodon_id,
      cdate: raw.cdate,
      originalActorId: raw.original_actor_id,
      notificationType: raw.notification_type,
      notificationActorId: raw.notification_actor_id,
      notificationFromActorId: raw.notification_from_actor_id,
      notificationCdate: raw.notification_cdate,
      notificationId: raw.notification_id,
    } : null);
}

const insertActorPreferencesQuery = `-- name: InsertActorPreferences :exec
INSERT INTO
  actor_preferences ("id")
VALUES
  (?)`;

export type InsertActorPreferencesParams = {
  id: string;
};

export async function insertActorPreferences(
  d1: D1Database,
  args: InsertActorPreferencesParams
): Promise<D1Result> {
  return await d1
    .prepare(insertActorPreferencesQuery)
    .bind(args.id)
    .run();
}

const insertReplyQuery = `-- name: InsertReply :exec
INSERT INTO
  actor_replies (id, actor_id, object_id, in_reply_to_object_id)
VALUES
  (?, ?, ?, ?)`;

export type InsertReplyParams = {
  id: string;
  actorId: string;
  objectId: string;
  inReplyToObjectId: string;
};

export async function insertReply(
  d1: D1Database,
  args: InsertReplyParams
): Promise<D1Result> {
  return await d1
    .prepare(insertReplyQuery)
    .bind(args.id, args.actorId, args.objectId, args.inReplyToObjectId)
    .run();
}

const insertActorQuery = `-- name: InsertActor :exec
INSERT INTO
  actors ("id", "mastodon_id", "type", "username", "domain", "properties", "cdate")
VALUES
  (?, ?, ?, ?, ?, ?, ?)`;

export type InsertActorParams = {
  id: string;
  mastodonId: string | null;
  type: string | null;
  username: string | null;
  domain: string | null;
  properties: string;
  cdate: string;
};

export async function insertActor(
  d1: D1Database,
  args: InsertActorParams
): Promise<D1Result> {
  return await d1
    .prepare(insertActorQuery)
    .bind(args.id, args.mastodonId, args.type, args.username, args.domain, args.properties, args.cdate)
    .run();
}

const updateActorAliasQuery = `-- name: UpdateActorAlias :exec
UPDATE actors
SET
  properties = JSON_SET(
    properties,
    '$.alsoKnownAs',
    IIF(
      JSON_EXTRACT(properties, '$.alsoKnownAs') IS NULL,
      JSON_ARRAY(?1),
      JSON_SET(JSON_EXTRACT(properties, '$.alsoKnownAs'), '$[#]', ?1)
    )
  )
WHERE
  id = ?2`;

export type UpdateActorAliasParams = {
  alias: number | string;
  id: string;
};

export async function updateActorAlias(
  d1: D1Database,
  args: UpdateActorAliasParams
): Promise<D1Result> {
  return await d1
    .prepare(updateActorAliasQuery)
    .bind(args.alias, args.id)
    .run();
}

const updateActorMastodonIdByMastodonIdQuery = `-- name: UpdateActorMastodonIdByMastodonId :exec
UPDATE actors
SET
  mastodon_id = ?1
WHERE
  mastodon_id = ?2`;

export type UpdateActorMastodonIdByMastodonIdParams = {
  next: string | null;
  current: string | null;
};

export async function updateActorMastodonIdByMastodonId(
  d1: D1Database,
  args: UpdateActorMastodonIdByMastodonIdParams
): Promise<D1Result> {
  return await d1
    .prepare(updateActorMastodonIdByMastodonIdQuery)
    .bind(args.next, args.current)
    .run();
}

const updateActorPropertiesQuery = `-- name: UpdateActorProperties :exec
UPDATE actors
SET
  properties = ?
WHERE
  id = ?`;

export type UpdateActorPropertiesParams = {
  properties: string;
  id: string;
};

export async function updateActorProperties(
  d1: D1Database,
  args: UpdateActorPropertiesParams
): Promise<D1Result> {
  return await d1
    .prepare(updateActorPropertiesQuery)
    .bind(args.properties, args.id)
    .run();
}

const selectActorQuery = `-- name: SelectActor :one
SELECT
  "id",
  "mastodon_id",
  "type",
  "properties",
  "cdate"
FROM
  actors
WHERE
  id = ?`;

export type SelectActorParams = {
  id: string;
};

export type SelectActorRow = {
  id: string;
  mastodonId: string | null;
  type: string | null;
  properties: string;
  cdate: string;
};

type RawSelectActorRow = {
  id: string;
  mastodon_id: string | null;
  type: string | null;
  properties: string;
  cdate: string;
};

export async function selectActor(
  d1: D1Database,
  args: SelectActorParams
): Promise<SelectActorRow | null> {
  return await d1
    .prepare(selectActorQuery)
    .bind(args.id)
    .first<RawSelectActorRow | null>()
    .then((raw: RawSelectActorRow | null) => raw ? {
      id: raw.id,
      mastodonId: raw.mastodon_id,
      type: raw.type,
      properties: raw.properties,
      cdate: raw.cdate,
    } : null);
}

const selectActorByMastodonIdQuery = `-- name: SelectActorByMastodonId :one
SELECT
  "id",
  "mastodon_id",
  "type",
  "properties",
  "cdate"
FROM
  actors
WHERE
  mastodon_id = ?`;

export type SelectActorByMastodonIdParams = {
  mastodonId: string | null;
};

export type SelectActorByMastodonIdRow = {
  id: string;
  mastodonId: string | null;
  type: string | null;
  properties: string;
  cdate: string;
};

type RawSelectActorByMastodonIdRow = {
  id: string;
  mastodon_id: string | null;
  type: string | null;
  properties: string;
  cdate: string;
};

export async function selectActorByMastodonId(
  d1: D1Database,
  args: SelectActorByMastodonIdParams
): Promise<SelectActorByMastodonIdRow | null> {
  return await d1
    .prepare(selectActorByMastodonIdQuery)
    .bind(args.mastodonId)
    .first<RawSelectActorByMastodonIdRow | null>()
    .then((raw: RawSelectActorByMastodonIdRow | null) => raw ? {
      id: raw.id,
      mastodonId: raw.mastodon_id,
      type: raw.type,
      properties: raw.properties,
      cdate: raw.cdate,
    } : null);
}

const selectActorByUsernameAndDomainQuery = `-- name: SelectActorByUsernameAndDomain :one
SELECT
  "id",
  "mastodon_id",
  "type",
  "properties",
  "cdate"
FROM
  actors
WHERE
  username = LOWER(?1)
  AND domain = ?2`;

export type SelectActorByUsernameAndDomainParams = {
  username: string;
  domain: string | null;
};

export type SelectActorByUsernameAndDomainRow = {
  id: string;
  mastodonId: string | null;
  type: string | null;
  properties: string;
  cdate: string;
};

type RawSelectActorByUsernameAndDomainRow = {
  id: string;
  mastodon_id: string | null;
  type: string | null;
  properties: string;
  cdate: string;
};

export async function selectActorByUsernameAndDomain(
  d1: D1Database,
  args: SelectActorByUsernameAndDomainParams
): Promise<SelectActorByUsernameAndDomainRow | null> {
  return await d1
    .prepare(selectActorByUsernameAndDomainQuery)
    .bind(args.username, args.domain)
    .first<RawSelectActorByUsernameAndDomainRow | null>()
    .then((raw: RawSelectActorByUsernameAndDomainRow | null) => raw ? {
      id: raw.id,
      mastodonId: raw.mastodon_id,
      type: raw.type,
      properties: raw.properties,
      cdate: raw.cdate,
    } : null);
}

const deleteActorQuery = `-- name: DeleteActor :exec
DELETE FROM actors
WHERE
  id = ?`;

export type DeleteActorParams = {
  id: string;
};

export async function deleteActor(
  d1: D1Database,
  args: DeleteActorParams
): Promise<D1Result> {
  return await d1
    .prepare(deleteActorQuery)
    .bind(args.id)
    .run();
}

const insertIdSequenceQuery = `-- name: InsertIdSequence :one
INSERT INTO
  id_sequences ("key", "value")
VALUES
  (
    ?1,
    COALESCE(
      (
        SELECT
          "value"
        FROM
          id_sequences
        WHERE
          "key" = ?1
      ),
      0
    ) + 1
  )
ON CONFLICT ("key") DO
UPDATE
SET
  "value" = excluded."value" RETURNING "value"`;

export type InsertIdSequenceParams = {
  key: string;
};

export type InsertIdSequenceRow = {
  value: number;
};

export async function insertIdSequence(
  d1: D1Database,
  args: InsertIdSequenceParams
): Promise<InsertIdSequenceRow | null> {
  return await d1
    .prepare(insertIdSequenceQuery)
    .bind(args.key)
    .first<InsertIdSequenceRow | null>();
}

const selectObjectRevisionsByObjectIDQuery = `-- name: SelectObjectRevisionsByObjectID :many
SELECT
  properties
FROM
  object_revisions
WHERE
  object_id = ?`;

export type SelectObjectRevisionsByObjectIDParams = {
  objectId: string;
};

export type SelectObjectRevisionsByObjectIDRow = {
  properties: string;
};

export async function selectObjectRevisionsByObjectID(
  d1: D1Database,
  args: SelectObjectRevisionsByObjectIDParams
): Promise<D1Result<SelectObjectRevisionsByObjectIDRow>> {
  return await d1
    .prepare(selectObjectRevisionsByObjectIDQuery)
    .bind(args.objectId)
    .all<SelectObjectRevisionsByObjectIDRow>();
}

const insertObjectRevisionQuery = `-- name: InsertObjectRevision :exec
INSERT INTO
  object_revisions ("object_id", "properties")
VALUES
  (?, ?)`;

export type InsertObjectRevisionParams = {
  objectId: string;
  properties: string;
};

export async function insertObjectRevision(
  d1: D1Database,
  args: InsertObjectRevisionParams
): Promise<D1Result> {
  return await d1
    .prepare(insertObjectRevisionQuery)
    .bind(args.objectId, args.properties)
    .run();
}

const insertRemoteObjectQuery = `-- name: InsertRemoteObject :exec
INSERT INTO
  objects (
    "id",
    "mastodon_id",
    "type",
    "cdate",
    "original_actor_id",
    "original_object_id",
    "reply_to_object_id",
    "properties",
    "local"
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, 0)`;

export type InsertRemoteObjectParams = {
  id: string;
  mastodonId: string;
  type: string;
  cdate: string;
  originalActorId: string | null;
  originalObjectId: string | null;
  replyToObjectId: string | null;
  properties: string;
};

export async function insertRemoteObject(
  d1: D1Database,
  args: InsertRemoteObjectParams
): Promise<D1Result> {
  return await d1
    .prepare(insertRemoteObjectQuery)
    .bind(args.id, args.mastodonId, args.type, args.cdate, args.originalActorId, args.originalObjectId, args.replyToObjectId, args.properties)
    .run();
}

const insertLocalObjectQuery = `-- name: InsertLocalObject :exec
INSERT INTO
  objects (
    "id",
    "mastodon_id",
    "type",
    "cdate",
    "original_actor_id",
    "original_object_id",
    "reply_to_object_id",
    "properties",
    "local"
  )
VALUES
  (?1, ?2, ?3, ?4, ?5, ?1, ?6, ?7, 1)`;

export type InsertLocalObjectParams = {
  id: string;
  mastodonId: string;
  type: string;
  cdate: string;
  originalActorId: string | null;
  replyToObjectId: string | null;
  properties: string;
};

export async function insertLocalObject(
  d1: D1Database,
  args: InsertLocalObjectParams
): Promise<D1Result> {
  return await d1
    .prepare(insertLocalObjectQuery)
    .bind(args.id, args.mastodonId, args.type, args.cdate, args.originalActorId, args.replyToObjectId, args.properties)
    .run();
}

const updateObjectMastodonIdByMastodonIdQuery = `-- name: UpdateObjectMastodonIdByMastodonId :exec
UPDATE objects
SET
  mastodon_id = ?1
WHERE
  mastodon_id = ?2`;

export type UpdateObjectMastodonIdByMastodonIdParams = {
  next: string;
  current: string;
};

export async function updateObjectMastodonIdByMastodonId(
  d1: D1Database,
  args: UpdateObjectMastodonIdByMastodonIdParams
): Promise<D1Result> {
  return await d1
    .prepare(updateObjectMastodonIdByMastodonIdQuery)
    .bind(args.next, args.current)
    .run();
}

const selectObjectQuery = `-- name: SelectObject :one
SELECT
  id, mastodon_id, type, cdate, original_actor_id, original_object_id, reply_to_object_id, properties, local
FROM
  objects
WHERE
  id = ?`;

export type SelectObjectParams = {
  id: string;
};

export type SelectObjectRow = {
  id: string;
  mastodonId: string;
  type: string;
  cdate: string;
  originalActorId: string | null;
  originalObjectId: string | null;
  replyToObjectId: string | null;
  properties: string;
  local: number;
};

type RawSelectObjectRow = {
  id: string;
  mastodon_id: string;
  type: string;
  cdate: string;
  original_actor_id: string | null;
  original_object_id: string | null;
  reply_to_object_id: string | null;
  properties: string;
  local: number;
};

export async function selectObject(
  d1: D1Database,
  args: SelectObjectParams
): Promise<SelectObjectRow | null> {
  return await d1
    .prepare(selectObjectQuery)
    .bind(args.id)
    .first<RawSelectObjectRow | null>()
    .then((raw: RawSelectObjectRow | null) => raw ? {
      id: raw.id,
      mastodonId: raw.mastodon_id,
      type: raw.type,
      cdate: raw.cdate,
      originalActorId: raw.original_actor_id,
      originalObjectId: raw.original_object_id,
      replyToObjectId: raw.reply_to_object_id,
      properties: raw.properties,
      local: raw.local,
    } : null);
}

const selectObjectByOriginalObjectIdQuery = `-- name: SelectObjectByOriginalObjectId :one
SELECT
  id, mastodon_id, type, cdate, original_actor_id, original_object_id, reply_to_object_id, properties, local
FROM
  objects
WHERE
  original_object_id = ?`;

export type SelectObjectByOriginalObjectIdParams = {
  originalObjectId: string | null;
};

export type SelectObjectByOriginalObjectIdRow = {
  id: string;
  mastodonId: string;
  type: string;
  cdate: string;
  originalActorId: string | null;
  originalObjectId: string | null;
  replyToObjectId: string | null;
  properties: string;
  local: number;
};

type RawSelectObjectByOriginalObjectIdRow = {
  id: string;
  mastodon_id: string;
  type: string;
  cdate: string;
  original_actor_id: string | null;
  original_object_id: string | null;
  reply_to_object_id: string | null;
  properties: string;
  local: number;
};

export async function selectObjectByOriginalObjectId(
  d1: D1Database,
  args: SelectObjectByOriginalObjectIdParams
): Promise<SelectObjectByOriginalObjectIdRow | null> {
  return await d1
    .prepare(selectObjectByOriginalObjectIdQuery)
    .bind(args.originalObjectId)
    .first<RawSelectObjectByOriginalObjectIdRow | null>()
    .then((raw: RawSelectObjectByOriginalObjectIdRow | null) => raw ? {
      id: raw.id,
      mastodonId: raw.mastodon_id,
      type: raw.type,
      cdate: raw.cdate,
      originalActorId: raw.original_actor_id,
      originalObjectId: raw.original_object_id,
      replyToObjectId: raw.reply_to_object_id,
      properties: raw.properties,
      local: raw.local,
    } : null);
}

const selectObjectByMastodonIdQuery = `-- name: SelectObjectByMastodonId :one
SELECT
  id, mastodon_id, type, cdate, original_actor_id, original_object_id, reply_to_object_id, properties, local
FROM
  objects
WHERE
  mastodon_id = ?`;

export type SelectObjectByMastodonIdParams = {
  mastodonId: string;
};

export type SelectObjectByMastodonIdRow = {
  id: string;
  mastodonId: string;
  type: string;
  cdate: string;
  originalActorId: string | null;
  originalObjectId: string | null;
  replyToObjectId: string | null;
  properties: string;
  local: number;
};

type RawSelectObjectByMastodonIdRow = {
  id: string;
  mastodon_id: string;
  type: string;
  cdate: string;
  original_actor_id: string | null;
  original_object_id: string | null;
  reply_to_object_id: string | null;
  properties: string;
  local: number;
};

export async function selectObjectByMastodonId(
  d1: D1Database,
  args: SelectObjectByMastodonIdParams
): Promise<SelectObjectByMastodonIdRow | null> {
  return await d1
    .prepare(selectObjectByMastodonIdQuery)
    .bind(args.mastodonId)
    .first<RawSelectObjectByMastodonIdRow | null>()
    .then((raw: RawSelectObjectByMastodonIdRow | null) => raw ? {
      id: raw.id,
      mastodonId: raw.mastodon_id,
      type: raw.type,
      cdate: raw.cdate,
      originalActorId: raw.original_actor_id,
      originalObjectId: raw.original_object_id,
      replyToObjectId: raw.reply_to_object_id,
      properties: raw.properties,
      local: raw.local,
    } : null);
}

const updateObjectPropertiesQuery = `-- name: UpdateObjectProperties :exec
UPDATE objects
SET
  properties = ?
WHERE
  id = ?`;

export type UpdateObjectPropertiesParams = {
  properties: string;
  id: string;
};

export async function updateObjectProperties(
  d1: D1Database,
  args: UpdateObjectPropertiesParams
): Promise<D1Result> {
  return await d1
    .prepare(updateObjectPropertiesQuery)
    .bind(args.properties, args.id)
    .run();
}

const selectAllPeerDomainsQuery = `-- name: SelectAllPeerDomains :many
SELECT
  domain
FROM
  peers`;

export type SelectAllPeerDomainsRow = {
  domain: string;
};

export async function selectAllPeerDomains(
  d1: D1Database
): Promise<D1Result<SelectAllPeerDomainsRow>> {
  return await d1
    .prepare(selectAllPeerDomainsQuery)
    .all<SelectAllPeerDomainsRow>();
}

const insertPeerQuery = `-- name: InsertPeer :exec
INSERT OR IGNORE INTO
  peers (domain)
VALUES
  (?)`;

export type InsertPeerParams = {
  domain: string;
};

export async function insertPeer(
  d1: D1Database,
  args: InsertPeerParams
): Promise<D1Result> {
  return await d1
    .prepare(insertPeerQuery)
    .bind(args.domain)
    .run();
}

const insertUserQuery = `-- name: InsertUser :exec
INSERT INTO
  users ("id", "actor_id", "email", "privkey", "privkey_salt", "pubkey", "is_admin", "cdate")
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?)`;

export type InsertUserParams = {
  id: string;
  actorId: string;
  email: string;
  privkey: ArrayBuffer;
  privkeySalt: ArrayBuffer;
  pubkey: string;
  isAdmin: number;
  cdate: string;
};

export async function insertUser(
  d1: D1Database,
  args: InsertUserParams
): Promise<D1Result> {
  return await d1
    .prepare(insertUserQuery)
    .bind(args.id, args.actorId, args.email, args.privkey, args.privkeySalt, args.pubkey, args.isAdmin, args.cdate)
    .run();
}

const selectUserByEmailQuery = `-- name: SelectUserByEmail :one
SELECT
  actors."id",
  actors."mastodon_id",
  actors."type",
  users."pubkey",
  actors."cdate",
  actors."properties",
  users.is_admin
FROM
  actors
  INNER JOIN users ON users.actor_id = actors.id
WHERE
  email = ?`;

export type SelectUserByEmailParams = {
  email: string;
};

export type SelectUserByEmailRow = {
  id: string;
  mastodonId: string | null;
  type: string | null;
  pubkey: string;
  cdate: string;
  properties: string;
  isAdmin: number;
};

type RawSelectUserByEmailRow = {
  id: string;
  mastodon_id: string | null;
  type: string | null;
  pubkey: string;
  cdate: string;
  properties: string;
  is_admin: number;
};

export async function selectUserByEmail(
  d1: D1Database,
  args: SelectUserByEmailParams
): Promise<SelectUserByEmailRow | null> {
  return await d1
    .prepare(selectUserByEmailQuery)
    .bind(args.email)
    .first<RawSelectUserByEmailRow | null>()
    .then((raw: RawSelectUserByEmailRow | null) => raw ? {
      id: raw.id,
      mastodonId: raw.mastodon_id,
      type: raw.type,
      pubkey: raw.pubkey,
      cdate: raw.cdate,
      properties: raw.properties,
      isAdmin: raw.is_admin,
    } : null);
}

const selectAdminByEmailQuery = `-- name: SelectAdminByEmail :one
SELECT
  actors."id",
  actors."mastodon_id",
  actors."type",
  users."pubkey",
  actors."cdate",
  actors."properties"
FROM
  actors
  INNER JOIN users ON users.actor_id = actors.id
WHERE
  users.is_admin = 1
  AND users.email = ?`;

export type SelectAdminByEmailParams = {
  email: string;
};

export type SelectAdminByEmailRow = {
  id: string;
  mastodonId: string | null;
  type: string | null;
  pubkey: string;
  cdate: string;
  properties: string;
};

type RawSelectAdminByEmailRow = {
  id: string;
  mastodon_id: string | null;
  type: string | null;
  pubkey: string;
  cdate: string;
  properties: string;
};

export async function selectAdminByEmail(
  d1: D1Database,
  args: SelectAdminByEmailParams
): Promise<SelectAdminByEmailRow | null> {
  return await d1
    .prepare(selectAdminByEmailQuery)
    .bind(args.email)
    .first<RawSelectAdminByEmailRow | null>()
    .then((raw: RawSelectAdminByEmailRow | null) => raw ? {
      id: raw.id,
      mastodonId: raw.mastodon_id,
      type: raw.type,
      pubkey: raw.pubkey,
      cdate: raw.cdate,
      properties: raw.properties,
    } : null);
}

